/*
* This source file is part of an OSTIS project. For the latest info, see http://ostis.net
* Distributed under the MIT License
* (See accompanying file COPYING.MIT or copy at http://opensource.org/licenses/MIT)
*/

#include "iotKeynodes.hpp"
#include "iotUtils.hpp"

#include <time.h>

#include "wrap/sc_stream.hpp"

#include "iotActions.hpp"

namespace iot
{
	/// TODO: move to define (autogenerated)
	ScAddr PeriodicalTaskManager::msActionPeriodical;

	PeriodicalTaskManager * PeriodicalTaskManager::msInstance = 0;

	PeriodicalTaskManager * PeriodicalTaskManager::getInstance()
	{
		check_expr(msInstance);
		return msInstance;
	}


	PeriodicalTaskManager::PeriodicalTaskManager()
		: mIsInitialized(false)
	{
		check_expr(msInstance == nullptr);
		msInstance = this;
	}

	PeriodicalTaskManager::~PeriodicalTaskManager()
	{
		delete mMemoryCtx;
	}

	void PeriodicalTaskManager::initialize()
	{
		mIsInitialized = true;

		mMemoryCtx = new ScMemoryContext(sc_access_lvl_make_min, "PeriodicalTaskManager");

		// try to find all periodical actions
		ScIterator3Ptr iterActions = mMemoryCtx->iterator3(
			msActionPeriodical,
			SC_TYPE(sc_type_arc_pos_const_perm),
			SC_TYPE(sc_type_const | sc_type_node));

		while (iterActions->next())
		{
			ScTemplate periodTempl;

			periodTempl
				.tripleWithRelation(
					iterActions->value(2) >> "action",
					ScType(sc_type_arc_common | sc_type_const),
					ScType(sc_type_node | sc_type_const) >> "value",
					ScType(sc_type_arc_pos_const_perm),
					Keynodes::nrel_period
				)
				.tripleWithRelation(
					"value",
					ScType(sc_type_arc_pos_const_perm),
					ScType(sc_type_link) >> "link",
					ScType(sc_type_arc_pos_const_perm),
					Keynodes::rrel_seconds
				)
				.triple(
					Keynodes::binary_int32,	/// TODO: use int32, because precision is a one second
					ScType(sc_type_arc_pos_const_perm),
					"link"
				);

			ScTemplateSearchResult searchResult;

			if (mMemoryCtx->helperSearchTemplate(periodTempl, searchResult))
			{
				check_expr(searchResult.getSize() > 0);
				ScTemplateSearchResultItem const item = searchResult.getResult(0);

				int32_t period = 0;
				ScStream stream;

				if (mMemoryCtx->getLinkContent(item["link"], stream) && (stream.size() == sizeof(period)))
				{
					stream.readType(period);
					appendAction(item["action"], period);
				}
			}
		}


	}

	void PeriodicalTaskManager::shutdown()
	{
		mIsInitialized = false;

		delete mMemoryCtx;
		mMemoryCtx = 0;
	}

	void PeriodicalTaskManager::appendAction(ScAddr const & action, uint32_t period)
	{
		/// TODO: make it thread safe
		time_t tm;
		time(&tm);

		mTaskSet.insert(Task(action, period, tm + period));
	}


	// ---------------

	SC_AGENT_IMPLEMENTATION(ANewPeriodicalActionAgent)
	{
		return SC_RESULT_ERROR;
	}
}