/*
* This source file is part of an OSTIS project. For the latest info, see http://ostis.net
* Distributed under the MIT License
* (See accompanying file COPYING.MIT or copy at http://opensource.org/licenses/MIT)
*/

#include "iotKeynodes.hpp"
#include "iotUtils.hpp"

#include <time.h>

#include "wrap/sc_stream.hpp"

#include "iotActions.hpp"

extern "C"
{
#include "glib.h"
}

GThread * gPeriodicalThread = 0;
GMutex gManagerLock;

struct Locker
{
	Locker()
	{
		g_mutex_lock(&gManagerLock);
	}

	~Locker()
	{
		g_mutex_unlock(&gManagerLock);
	}
};

namespace iot
{
	// thread loop
	gpointer periodical_task_loop(gpointer data)
	{
		PeriodicalTaskManager * taskManager = PeriodicalTaskManager::getInstance();
		while (taskManager->isRunning())
		{
			taskManager->tick();
			g_usleep(1000000);	// one second sleep
		}

		return 0;
	}


	/// TODO: move to define (autogenerated)
	ScAddr PeriodicalTaskManager::msActionPeriodical;

	PeriodicalTaskManager * PeriodicalTaskManager::msInstance = 0;

	PeriodicalTaskManager * PeriodicalTaskManager::getInstance()
	{
		check_expr(msInstance);
		return msInstance;
	}


	PeriodicalTaskManager::PeriodicalTaskManager()
		: mIsInitialized(false)
		, mIsRunning(false)
	{
		check_expr(msInstance == nullptr);
		msInstance = this;
	}

	PeriodicalTaskManager::~PeriodicalTaskManager()
	{
		delete mMemoryCtx;
	}

	void PeriodicalTaskManager::initialize()
	{
		check_expr(!mIsInitialized);
		mIsInitialized = true;

		mMemoryCtx = new ScMemoryContext(sc_access_lvl_make_min, "PeriodicalTaskManager");

		// try to find all periodical actions
		ScIterator3Ptr iterActions = mMemoryCtx->iterator3(
			msActionPeriodical,
			SC_TYPE(sc_type_arc_pos_const_perm),
			SC_TYPE(sc_type_const | sc_type_node));

		while (iterActions->next())
		{
			ScTemplate periodTempl;

			periodTempl
				.tripleWithRelation(
					iterActions->value(2) >> "action",
					ScType(sc_type_arc_common | sc_type_const),
					ScType(sc_type_node | sc_type_const) >> "value",
					ScType(sc_type_arc_pos_const_perm),
					Keynodes::nrel_period
				)
				.tripleWithRelation(
					"value",
					ScType(sc_type_arc_pos_const_perm),
					ScType(sc_type_link) >> "link",
					ScType(sc_type_arc_pos_const_perm),
					Keynodes::rrel_seconds
				)
				.triple(
					Keynodes::binary_int32,	/// TODO: use int32, because precision is a one second
					ScType(sc_type_arc_pos_const_perm),
					"link"
				);

			ScTemplateSearchResult searchResult;

			if (mMemoryCtx->helperSearchTemplate(periodTempl, searchResult))
			{
				check_expr(searchResult.getSize() > 0);
				ScTemplateSearchResultItem const item = searchResult.getResult(0);

				int32_t period = 0;
				ScStream stream;

				if (mMemoryCtx->getLinkContent(item["link"], stream) && (stream.size() == sizeof(period)))
				{
					stream.readType(period);
					appendAction(item["action"], period);
				}
			}
		}

		// run thread
		mIsRunning = true;
		check_expr(gPeriodicalThread == 0);
		gPeriodicalThread = g_thread_new("PeriodicalTaskThread", periodical_task_loop, 0);
	}

	void PeriodicalTaskManager::shutdown()
	{	
		mIsRunning = false;
		g_thread_join(gPeriodicalThread);
		gPeriodicalThread = 0;
		
		delete mMemoryCtx;
		mMemoryCtx = 0;

		mIsInitialized = false;
	}

	void PeriodicalTaskManager::appendAction(ScAddr const & action, uint32_t period)
	{
		time_t tm;
		time(&tm);

		Locker lock;
		mTaskSet.insert(Task(action, period, tm + period));
	}

	void PeriodicalTaskManager::tick()
	{
		time_t tm;
		time(&tm);

		Locker lock;
		tTaskSet::iterator it = mTaskSet.begin();
		while (it != mTaskSet.end())
		{
			Task task = *it;

			if (task.nextRunTime <= (uint64_t)tm)
			{
				// run action
				ScTemplate initTempl;

				initTempl.triple(
					Keynodes::command_initiated,
					ScType(sc_type_arc_pos_const_perm),
					task.action);

				ScTemplateSearchResult searchResult;
				if (!mMemoryCtx->helperSearchTemplate(initTempl, searchResult))
				{
					ScTemplateGenResult genResult;
					mMemoryCtx->helperGenTemplate(initTempl, genResult);

					task.nextRunTime += task.period;
					mTaskSet.erase(*it);
					mTaskSet.insert(task);

					it = mTaskSet.begin();
				}
			}
			else
			{
				break;
			}

			// didn't erase first element
			++it;
		}
	}

	bool PeriodicalTaskManager::isRunning() const
	{
		return mIsRunning;
	}

	// ---------------

	SC_AGENT_IMPLEMENTATION(ANewPeriodicalActionAgent)
	{
		return SC_RESULT_ERROR;
	}
}